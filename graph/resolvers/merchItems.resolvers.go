package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/ut-sama-art-studio/art-market-backend/graph"
	"github.com/ut-sama-art-studio/art-market-backend/graph/model"
	"github.com/ut-sama-art-studio/art-market-backend/middlewares"
	"github.com/ut-sama-art-studio/art-market-backend/services/fileservice"
	merchitems "github.com/ut-sama-art-studio/art-market-backend/services/merchservice"
	"github.com/ut-sama-art-studio/art-market-backend/services/userservice"
)

// CreateMerch is the resolver for the createMerch field.
func (r *mutationResolver) CreateMerch(ctx context.Context, input model.NewMerch) (*model.MerchItem, error) {
	ownerId := middlewares.ContextUserID(ctx)
	user, err := userservice.GetUserByID(ownerId)
	if err != nil {
		return nil, err
	}
	if user.Role != "artist" && user.Role != "director" && user.Role != "admin" {
		return nil, fmt.Errorf("user is not an artist")
	}

	merchId := uuid.New().String()
	folderPath := merchId // store images under merchId
	// Process uploaded images and obtain URLs
	imageURLs := make([]*string, 5) // init with nils
	for i, file := range input.Images {
		// Upload the file and get the URL
		url, err := fileservice.UploadFileToS3(*file, ownerId, folderPath)
		if err != nil {
			return nil, fmt.Errorf("failed to upload file: %w", err)
		}
		imageURLs[i] = &url
	}

	merch := merchitems.MerchItem{
		ID:          merchId,
		OwnerID:     ownerId,
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Inventory:   input.Inventory,
		Type:        input.Type,
		Height:      input.Height,
		Width:       input.Width,
		Unit:        input.Unit,
		ImageURLs:   imageURLs,
	}

	_, err = merch.Create()
	if err != nil {
		fileservice.DeleteUserFolder(ownerId, folderPath)
		return nil, fmt.Errorf("could not create merch item: %w", err)
	}
	return merch.ToGraphqlMerchItem(), nil
}

// UpdateMerch is the resolver for the updateMerch field.
func (r *mutationResolver) UpdateMerch(ctx context.Context, input model.UpdateMerch) (*model.MerchItem, error) {
	panic(fmt.Errorf("not implemented: UpdateMerch - updateMerch"))
}

// DeleteMerch is the resolver for the deleteMerch field.
func (r *mutationResolver) DeleteMerch(ctx context.Context, id string) (bool, error) {
	// Fetch the merchandise item from the database
	merch, err := merchitems.GetByID(id)
	if err != nil {
		log.Printf("Error fetching merch item %s: %v", id, err)
		return false, fmt.Errorf("could not find merch item: %w", err)
	}

	ownerId := middlewares.ContextUserID(ctx)
	if ownerId != merch.OwnerID {
		log.Printf("No permission to delete this merch: user %s does not own merch %s\n", ownerId, id)
		return false, fmt.Errorf("no permission to delete this merch: %w", err)
	}

	// Delete the merchandise item from the database
	err = merchitems.DeleteByID(merch.ID)
	if err != nil {
		log.Printf("Error deleting merch item %s: %v\n", id, err)
		return false, fmt.Errorf("could not delete merch item: %w", err)
	}

	// Delete the associated images from S3
	err = fileservice.DeleteUserFolder(merch.OwnerID, merch.ID)
	if err != nil {
		log.Printf("Error deleting images for merch\n")
	}
	return true, nil
}

// UserMerchItems is the resolver for the userMerchItems field.
func (r *queryResolver) UserMerchItems(ctx context.Context, userID string) ([]*model.MerchItem, error) {
	// Fetch the user's merchandise items from the database
	items, err := merchitems.GetByOwnerID(userID)
	if err != nil {
		log.Printf("Error fetching merch items for user %s: %v", userID, err)
		return nil, fmt.Errorf("could not retrieve merch items: %w", err)
	}

	// Convert database objects to GraphQL model objects
	var merchItems []*model.MerchItem
	for _, item := range items {
		merchItems = append(merchItems, item.ToGraphqlMerchItem())
	}

	return merchItems, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
